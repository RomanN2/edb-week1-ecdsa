import {
  assert_default,
  hexToBytes
} from "./chunk-GII4UDT4.js";

// node_modules/ethereum-cryptography/esm/utils.js
var assertBool = assert_default.bool;
var assertBytes = assert_default.bytes;
function bytesToUtf8(data) {
  if (!(data instanceof Uint8Array)) {
    throw new TypeError(`bytesToUtf8 expected Uint8Array, got ${typeof data}`);
  }
  return new TextDecoder().decode(data);
}
function hexToBytes2(data) {
  const sliced = data.startsWith("0x") ? data.substring(2) : data;
  return hexToBytes(sliced);
}
function equalsBytes(a, b) {
  if (a.length !== b.length) {
    return false;
  }
  for (let i = 0; i < a.length; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}
function wrapHash(hash) {
  return (msg) => {
    assert_default.bytes(msg);
    return hash(msg);
  };
}
var crypto = (() => {
  const webCrypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
  const nodeRequire = typeof module !== "undefined" && typeof module.require === "function" && module.require.bind(module);
  return {
    node: nodeRequire && !webCrypto ? nodeRequire("crypto") : void 0,
    web: webCrypto
  };
})();

export {
  assertBool,
  assertBytes,
  bytesToUtf8,
  hexToBytes2 as hexToBytes,
  equalsBytes,
  wrapHash,
  crypto
};
//# sourceMappingURL=chunk-P2Y4A2JL.js.map
